/*
Подмассивы
Условия
На складе хранятся шурупы в заводских упаковках по X штук.
Задача упаковщика Ивана – распределить шурупы по заказам покупателей в соответствии с заказанным количеством,
не нарушая при этом хронологический порядок заказов. То есть пока полностью не укомплектован i-тый заказ,
Иван не приступает к комплектации i+1-го заказа.

В конце смены Ивану необходимо оформить на скомплектованные заказы набор складских документов.
Причем в каждом отдельном документе он должен отразить целое количество истраченных (распределенных)
заводских упаковок и целое количество скомплектованных заказов.
Дробные числа в документе недопустимы, поэтому каждый раз, закончив работу, Иван рассчитывает,
сколько последовательностей заказов ему удалось сформировать таким образом,
чтобы на каждую последовательность тратилось целое количество заводских упаковок.
В уме проводить такие расчеты каждый раз довольно сложно, поэтому он хочет решить задачу алгоритмически:

Дан массив из n элементов a0, a1, . . . an−1 и число X.

Вам требуется найти число подмассивов [al,al+1,...ar], таких что сумма al +al+1 +···+ar делится на X без остатка.

Примечание

В первом примере подходят подмассивы [a0, a1] и [a1, a2].
Во втором примере подходят подмассивы [a0, a1], [a2, a3] и [a0, a1, a2, a3].

Формат входных данных
В первой строке входных данных содержится два целых числа n и X (1 ≤ n ≤ 105, 1 ≤ X ≤ 109).

Во второй строке содержатся n целых чисел a0, a1, . . . an−1 разделенные пробелом — элементы массива (1 ≤ ai ≤ 109).

Формат выходных данных
Выведите одно число — число подмассивов, сумма элементов которых кратна числу X.

Примеры
Входные данные:
3 2
1 1 1
Выходные данные:
2

Входные данные:
4 3
1 2 2 1
Выходные данные:
3
*/
package main

import (
	"fmt"
)

// без выделение памяти
/*
func subArray(arr []int, n, k int) int {
	var cnt int
	for i := 0; i < n; i++ {
		sum := 0
		for j := i; j < n; j++ {
			sum += arr[j]
			if sum%k == 0 {
				cnt++
			}
		}
	}
	return cnt
}
*/

// использование хэш-таблицы
/*
func subArraysHT(arr []int, k int) int {
//	ht := map[int]int{0: 1}
//	count, sum := 0, 0
//	for _, elem := range arr {
//		sum = (sum + elem) % k
//		if sum < 0 {
//			sum += k
//		}
//		count += ht[sum]
//		ht[sum]++
//	}
//	return count
}
*/

func subarraysDivByK(nums []int, k int) (res int) {
	counter := map[int]int{0: 1}
	var sum int

	for _, num := range nums {
		sum += num
		remain := sum % k
		if remain < 0 {
			remain += k
		}
		if c, ok := counter[remain]; ok {
			res += c
		}
		counter[remain]++
	}
	return res
}

func main() {
	var n, k int

	fmt.Scanf("%d%d", &n, &k)
	m := make([]int, n)

	for i := 0; i < n; i++ {
		fmt.Scanf("%d", &m[i])
	}

	fmt.Printf("%d", subarraysDivByK(m, k))
}
